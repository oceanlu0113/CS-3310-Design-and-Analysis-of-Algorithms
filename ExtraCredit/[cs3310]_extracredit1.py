# -*- coding: utf-8 -*-
"""[CS3310] ExtraCredit1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BiJbnE5Xz9qtt7uSi23g7rRq5MvUewJA
"""

import numpy as np

inf = 1e10 
def floyd(weights):
    V = len(weights)
    distance_matrix = weights
    for k in range(V):
        next_distance_matrix = [list(row) for row in distance_matrix]
        for i in range(V):
            for j in range(V):
                next_distance_matrix[i][j] = min(distance_matrix[i][j], distance_matrix[i][k] + distance_matrix[k][j])
        distance_matrix = next_distance_matrix
    return distance_matrix

def path(graph):
  graph = np.array(graph)
  v = len(graph)
  p = np.zeros(graph.shape)
  for i in range(0,v):
      for j in range(0,v):
          p[i,j] = i
          if (i != j and graph[i,j] == 0): 
              p[i,j] = -30000 
              graph[i,j] = 30000 # set zeros to any large number which is bigger then the longest way
  for k in range(0,v):
      for i in range(0,v):
          for j in range(0,v):
              if graph[i,j] > graph[i,k] + graph[k,j]:
                  graph[i,j] = graph[i,k] + graph[k,j]
                  p[i,j] = p[k,j]
  return p

def constructPath(p, i, j):
    i,j = int(i), int(j)
    if(i==j):
      print (i,)
    elif(p[i,j] == -30000):
      print (i,'-',j)
    else:
      ConstructPath(p, i, p[i,j]);
      print(j,)

def printMatrix(matrix):
  for row in matrix:
    for elem in row:
      if elem == 1e10:
        print ("inf", end = " "),
      else:
        print (elem, end = " "),
    print()

################################
# Feel free to edit the graph! #
################################
graph = [
    [0,1,inf,1,5],
    [9,0,3,2,inf],
    [inf,inf,0,4,inf],
    [inf,inf,2,0,3],
    [3,inf,inf,inf,0]
]

print("D array:")
printMatrix(floyd(graph))
print("\nP array:")
printMatrix(path(graph))
print()

while True:
  print("Enter 'q' to quit")
  v1 = input("Enter a start vertice: ")
  if v1 == "q":
    break
  v2 = input("Enter an end vertice: ")
  if v2 == "q":
    break
  print("\nPath taken from start to end vertices:")
  constructPath(path(graph),v1,v2)