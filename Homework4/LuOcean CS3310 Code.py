# -*- coding: utf-8 -*-
"""[CS3310] Homework #4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A5GZejz7OMGhruiGJE0L3CTSy5Z-Wax7
"""

from itertools import combinations
from operator import truediv

def totalvalue(comb):
    totwt = totval = 0
    for item, wt, val in comb:
        totwt  += wt
        totval += val
    return (totval, -totwt) if totwt <= max_weight else (0, 0)

# a. The Brute-Force solution method (returns combination of any length from the times)
def anycomb(items):
    node = 0
    for r in range(1, len(items)+1):
      for comb in combinations(items, r):
        node = node + 1
    print "Nodes visited ", node
    return (comb
             for r in range(1, len(items)+1)
             for comb in combinations(items, r))

# b. The Backtracking solution method
def backtrack(items, limit):
    nodes_visited = 0
    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]
    for j in xrange(1, len(items) + 1):
        item, wt, val = items[j-1]
        for w in xrange(1, limit + 1):
            if wt > w:
                table[j][w] = table[j-1][w]
                nodes_visited = nodes_visited + 1
            else:
                table[j][w] = max(table[j-1][w], table[j-1][w-wt] + val)
    result = []
    w = limit
    for j in range(len(items), 0, -1):
        was_added = table[j][w] != table[j-1][w]
        if was_added:
            item, wt, val = items[j-1]
            result.append(items[j-1])
            w -= wt
    print "Nodes visited: ", nodes_visited
    return result

# c. The Branch-and-Bound solution method
class State(object):
    def __init__(self, level, benefit, weight, token):
        self.level = level
        self.benefit = benefit
        self.weight = weight
        self.token = token
        self.available = self.token[:self.level]+[1]*(len(data_value)-level)
        self.ub = self.upperbound()

    def upperbound(self): #
        upperbound = 0 
        weight_accumulate = 0
        for i in range(len(data_weight)):
            if data_weight[i] * self.available[i] <= max_weight - weight_accumulate:
                weight_accumulate += data_weight[i] * self.available[i]
                upperbound += data_value[i] * self.available[i]
            else:
                upperbound += data_value[i] * (max_weight - weight_accumulate) / data_weight[i] * self.available[i]
                break
        return upperbound

    def develop(self):
        level = self.level + 1
        if self.weight + data_weight[self.level] <= max_weight: #if not overweighted, give left child
            left_weight = self.weight + data_weight[self.level]
            left_benefit = self.benefit + data_value[self.level]
            left_token = self.token[:self.level]+[1]+self.token[self.level+1:]
            left_child = State(level, left_benefit, left_weight, left_token)
        else: left_child = None
        right_child = State(level, self.benefit, self.weight, self.token)
        if left_child != None: 
            return [left_child, right_child]
        else: return [right_child]


'''main method'''

# When the user starts the program, they should be asked for the following input:
print("How many items are there to potentially take?")
num_items = input()
data_item = []
data_weight = []
data_value = []
# ● What is the weight and profit of each item?
for x in range(num_items):
  item = raw_input("Enter item (string): ")
  data_item.append(item)
  weight = input("Enter weight (numeric): ")
  data_weight.append(weight)
  value = input("Enter profit (numeric): ")
  data_value.append(value)
# ● What is the max weight the bag can hold?
print("What is the max weight the bag can hold?")
max_weight = input()

'''
# Example data set
data_item = ['map', 'compass', 'water', 'sandwich', 'glucose', 'tin', 'banana', 'apple', 'cheese', 'beer', 'suntan cream', 'camera', 't-shirt', 'trousers', 'umbrella', 
             'waterproof trousers', 'waterproof overclothes', 'note-case', 'sunglasses',  'towel', 'socks', 'book']
data_weight = [9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11, 32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30]
data_value = [150, 35, 200, 160, 60, 45, 60, 40, 30, 10, 70, 30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10]
max_weight = 400
# Total weight:  396
# Total value:  1030
# Items: banana, compass, glucose, map, note-case, sandwich, socks, sunglasses, suntan cream, water, waterproof overclothes, waterproof trousers
'''

data_eff = map(truediv, data_value, data_weight)
order = [i[0] for i in sorted(enumerate(data_eff), key=lambda x:x[1], reverse=True)]
#sort data based on their 'efficiency', i.e. value/weight
data_eff = [data_eff[i] for i in order]
data_weight = [data_weight[i] for i in order]
data_value = [data_value[i] for i in order]
data_item = [data_item[i] for i in order]

data_sorted = sorted(zip(data_item, data_weight, data_value), key=lambda (i,w,v):v//w, reverse=True)

print "data entered: ", (data_sorted)

# a. The Brute-Force solution that implicitly builds the entire state space tree.
print("\nThe Brute-Force solution:")
bag = max(anycomb(data_sorted), key=totalvalue)
val, wt = totalvalue(bag)
print "Total weight: ", -wt
print "Total value: ", val
print("Items: " + ', '.join(sorted(item for item,_,_ in bag)))

# b. The Backtracking solution.
print("\nThe Backtracking solution:")
bagged = backtrack(data_sorted, max_weight)
val, wt = totalvalue(bagged)
print "Total weight: ", -wt
print "Total value: ", val
print("Items: " + ', '.join(sorted(item for item,_,_ in bagged)))

# c. The Branch-and-Bound solution. Make sure to use the best-first search version.
print("\nThe Branch-and-Bound solution:")
Root = State(0, 0, 0, [0]*len(data_value))
waiting_States = [] 
current_state = Root
nodes = 0
while current_state.level < len(data_value):
    waiting_States.extend(current_state.develop())
    waiting_States.sort(key=lambda x: x.ub) 
    current_state = waiting_States.pop() 
    nodes = nodes + 1
best_solution = current_state
best_item = []
for i in range(len(best_solution.token)):
    if (best_solution.token[i] == 1):
        best_item.append(data_item[i])
print "Nodes visited: ", nodes
print "Total weight: ", best_solution.weight
print "Total value: ", best_solution.benefit
print "Items: " + ', '.join(sorted(best_item))